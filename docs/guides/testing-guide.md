Comprehensive Testing GuideðŸ§ª Testing PhilosophyEvery build must verify that MCP conversations work correctly. We test at multiple levels to ensure correctness, from individual functions to full, real-world protocol conversations.ðŸ“Š Test Layers & StrategyThis project uses a layered testing strategy to ensure code quality and system stability. Each layer has a specific purpose and is run at different stages of the development and deployment lifecycle.Test LayerPurposeSpeedLocationWhen to RunUnit TestsTest individual functions and packages in isolation.Fast (< 10 secs)*_test.go filesEvery commit, PR checks.Integration TestsTest component interactions and protocol compliance.Medium (< 30 secs)./tests/integration/Every commit, PR checks.Scenario TestsTest full MCP protocol conversations and compliance.Medium (< 1 min)./tests/scenarios/Pre-deploy, staging validation.E2E / Shell Script TestsTest real client compatibility, transport behavior, and debug system integration.Slow (1-2 mins)./scripts/test/Pre-deploy, release validation.Integration Test Strategy: Testing Against a Deployed ServiceBy default, integration tests (make integration-test) run against the live, deployed instance at https://mcp-adapters.fly.dev/mcp.Why Test Against a Deployed Instance?Real Environment: It tests the actual production setup, including Fly.io configuration.Auth Disabled: The deployed test instance is run with --disable-auth for easier testing.Always Available: There's no need to manage local servers for standard tests.CI/CD Ready: This approach works seamlessly in GitHub Actions without extra setup.Catches Deployment Issues: It immediately verifies that the deployed service is configured and running correctly.Local Integration Testing (For Development)For local debugging, you can run tests against a local server.# Option 1: Use the dedicated make target
make integration-test-local

# Option 2: Override the environment variable
MCP_SERVER_URL=http://localhost:8080/mcp make integration-test
ðŸš€ Quick Testing CommandsTargetDescriptionWhen to Usemake testRuns all Go tests including unit and integration tests.Before a commit for fast validation.make unit-testRuns only the unit tests.For the quickest feedback during development.make integration-testRuns integration tests against the deployed service.After refactoring components.make scenario-test-localRuns end-to-end scenario tests against a local server.Before deploying new features.make e2e-test-prodRuns end-to-end tests with progress dots.For release validation.make test-ciRuns all tests with JUnit XML output for CI systems.In the CI/CD pipeline.make test-verboseRuns tests with detailed, human-readable output.When debugging a failing test.ðŸ› ï¸ Development WorkflowMake your code changes.Run make unit-test for fast feedback.Run make test for a full validation before committing.Optionally, use the inspector for manual testing: npx @modelcontextprotocol/inspector ./bin/cowpilot.Commit your changes.ðŸ“ Writing TestsTest Naming ConventionGo tests should be descriptive and clearly state what they are testing, using a Behavior-Driven Development (BDD) style. Use t.Run to structure sub-tests within a larger test function.// Good: A descriptive name explaining the test's purpose
func TestHealthEndpoint_ReturnsStatusOK_When_ServerIsRunning(t *testing.T) {}

// Good: Using t.Run for sub-tests
t.Run("JSON-RPC request with wrong version returns invalid request error", func(t *testing.T) {
    // test implementation
})
ðŸ” Test Output & FormattingThe project uses gotestsum to provide clean, readable test output. It is installed via go install gotest.tools/gotestsum@latest. The Makefile will automatically use it if it's installed, falling back to the standard go test if not.Common Output Formats:testname: Clean output showing test names with pass/fail status (default for make test).dots-v2: A compact view with one dot per test, ideal for end-to-end tests.You can also use watch mode during development for continuous feedback: gotestsum --watch ./....ðŸ› Debugging Failed TestsCheck Logs: Run tests with debug mode enabled: MCP_DEBUG=true make test.Run a Specific Test: Isolate a single test with verbose output: go test -v -run TestEchoTool ./....Manual Protocol Testing: Use curl or the MCP Inspector to manually interact with the server and replicate the issue.ðŸ“ˆ Test CoverageYou can generate a test coverage report using make coverage, which will create an coverage.html file to view in your browser.Coverage Targets:Unit tests: >80%Integration tests: >70%Overall: >75%ðŸ”§ Test ConfigurationEnvironment VariablesMCP_SERVER_URL: Overrides the target for integration tests. Defaults to the deployed instance.LOCAL_TEST=true: A flag to force tests against a local server.MCP_DEBUG=true: Enables debug mode for more verbose logging.TEST_TIMEOUT=30s: Sets the timeout for tests.âœ… Test ChecklistBefore Committing:[ ] All unit and integration tests pass (make test).[ ] New features are covered by tests.[ ] Test names are descriptive.[ ] Test coverage has not decreased.Before Deploying:[ ] All local tests pass, including scenario tests.[ ] All shell script tests pass.[ ] Manual inspection with the inspector tool works as expected.